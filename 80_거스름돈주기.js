// 그리디
// - 최적 부분 구조 : 부분해를 푸는 과정이 최적해를 구하는 과정과 일치
// - 그리디 선택 속성 : 선택 과정이 다른 과정에 영향을 주지 않음

// 최소 신장 트리
// 그리디 알고리즘을 사용하는 대표적인 트리 형태의 자료구조

// 신장 트리(spanning tree)란?
// 모든 정점이 간선으로 연결되어 있고 간선 개수가 정점 개수보다 하나 적은 그래프다.

// 최소 신장 트리란?
// - 신장 트리 중 간선의 가중치 합이 최소면 최소 신장 트리.
// - 경우에 따라 최소 신장 트리는 하나가 아닐 수도 있다.
// - MST(Minimum Spanning Tree)
// - 항공기의 운항 경로를 최적화할 때 MST를 활용한다. 네트워크 분야에서도 많이 활용.

// 프림 알고리즘으로 최소 신장 트리 구하기
// 1. 임의의 정점을 하나 선택해서 최소 신장 트리에 추가한다.
// 2. 최소 신장 트리와 연결되어 있는 정점 중 가장 가중치가 적은 정점을 최소 신장 트리에 추가한다.(그리디)
// 단 순환을 형성하지 않는 정점을 추가한다.
// 3. 과정 2를 신장 트리 조건에 만족할 때까지 반복

// 크루스칼 알고리즘으로 최소 신장 트리 구하기
// 1. 그래프의 모든 간선을 가중치 기준으로 오름차순 정렬
// 2. 가중치가 낮은 간선부터 최소 신장 트리에 하나씩 추가한다(그리디)
// 단 사이클을 형성하지 않아야 함.
// 3. 과정 2를 신장 트리 조건에 만족할 때까지 반복한다.

// 배낭 문제
// - 짐을 쪼갤 수 있는 부분 배낭 문제
//   - 짐별로 무게당 가치
//   - 무게당 가치가 높은 짐부터 넣을 수 있는 만큼

// - 짐을 쪼갤 수 없는 배낭 문제
//   - 그리디 알고리즘으로 X

// 거스름돈 주기
// 상점에서 계산을 마치고 거스름돈을 돌려받아야 한다.
// 다만 거스름돈을 최소한의 화폐 수로 받고 싶다.
// 거스름돈 amount가 있을 때 화폐 단위 [1, 10, 50, 100]을 최소한으로 사용한 화폐 배열을 반환하는 solution() 함수를 반환하라
// 반환하는 값의 화폐 단위는 내림차순이어야 한다.
// amount는 자연수다.
// 화폐 단위는 1, 10, 50, 100이며 화폐 개수는 무한이다.

function solution(amount) {
  const coins = [1, 10, 50, 100];
  coins.sort((a, b) => b - a); // 내림차순으로 정렬
  const change = []; // 거스름돈을 담을 배열

  for (const coin of coins) {
    while (amount >= coin) {
      change.push(coin);
      amount -= coin;
    }
  }

  return change;
}

console.log(solution(123));
console.log(solution(350));
